
section .data
    format db 'Number fuck youuuu is %d', 10, 0
    format2 db 'Last byte: %hhd %c', 10, 0
    format3 db 'tmpSum is %d', 10, 0
    formatIndex db 'Index is %d', 10, 0
    call2nd     db '2nd call', 10, 0
    opPar         db 'what the fuckassssssssssssssssss', 10, 0


section .text

global expression
global term
global factor

extern printf

; `factor(char *p, int *i)`
;       Evaluates "(expression)" or "number" expressions 
; @params:
;	p -> the string to be parsed
;	i -> current position in the string
; @returns:
;	the result of the parsed expression
factor:
        push    ebp
        mov     ebp, esp

        mov     ebx, dword[ebp + 8]     ; the beginning of the string
        mov     edx, dword[ebp + 12]    ; pointer to the current index

        add     ebx, dword[edx]         ; the address of the current inspected character
                                        ; in the string
        cmp     byte[ebx], '('
        je      eval_expression

        ;; If the first character is not a paranthesis,
        ;; then it means that it's a number and has to be
        ;; calculated
        xor     eax, eax                ; store the number in eax

number_loop:
        ;; The character should has a value between
        ;; '0' and '9' to be part of a number
        cmp     byte[ebx], '0'
        jl      factor_out
        cmp     byte[ebx], '9'
        jg      factor_out

        ; pusha

        ; push dword[ebx]
        ; push dword[ebx]
        ; push format2
        ; call printf
        ; add esp, 12

        ; popa


        lea     eax, [eax * 5]
        lea     eax, [eax * 2]          ; multiply the old eax by 10 (5 * 2) and then add the new digit
                                        ; (because: lea eax, [eax * 10] is not valid)

        ; pusha

        ; push eax
        ; push format
        ; call printf
        ; add esp, 8

        ; popa

        xor     ecx, ecx                ; store the current digit in ecx, for the next addition to eax
        mov     cl, byte[ebx]
        add     eax, ecx
        sub     eax, '0'                ; eax becomes (10 * eax) + (char_digit - '0')

        inc     dword[edx]              ; increment the *i
        inc     ebx
        jmp     number_loop

eval_expression:
        inc     dword[edx]              ; get rid of the first paranthesis: '('

        ;; Since after this call, registers will no longer be used
        ;; in this function, if they are modified in expression() it doesn't matter,
        ;; and I don't push the values of the registers to the stack
        push    dword[ebp + 12]         ; calculate the expression
        push    dword[ebp + 8]          ; until the closing brace is reached
        call    expression
        add     esp, 8

        ;; Here, eax contains the result returned by the expression() call,
        ;; so nothing more has to be done
factor_out:
        leave
        ret

; `term(char *p, int *i)`
;       Evaluates "factor" * "factor" or "factor" / "factor" expressions 
; @params:
;	p -> the string to be parsed
;	i -> current position in the string
; @returns:
;	the result of the parsed expression
term:
        push    ebp
        mov     ebp, esp

        ; push call2nd
        ; call printf
        ; add esp, 4

        ;; Evaluation of the first factor inside the term
        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    factor
        add     esp, 8
        ;; eax has now the result generated by the first evaluation
        ;; and will be used to find the total result

;         pusha
;         push eax
;         push format
;         call printf
;         add esp, 4
;         pop  eax
; popa

        mov     ebx, dword[ebp + 8]
        mov     edx, dword[ebp + 12]


;; *i is updated in every factor() call, and the loop goes until the character
;; pointed by (p + *i) is different than '/' or '*'
while_div_or_mul:
        add     ebx, dword[edx]         ; the address of the sign (p + *i)

        cmp     byte[ebx], '/'         ; the current sign should be either '\', either '*'
        je      eval_next_factor
        cmp     byte[ebx], '*'
        je      eval_next_factor
        jmp     term_out

eval_next_factor:
        inc     dword[edx]              ; go past the sign

        push    eax                     ; save the used registers on the stack
        push    ebx
        push    edx

        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    factor
        add     esp, 8
        mov     ecx, eax                ; store the result of factor() in ebx

        pop     edx                     ; restore the registers from stack
        pop     ebx
        pop     eax

        ;; Decide what operation should be made between eax and ebx
        cmp     byte[ebx], '/'
        je      division
        jmp     multiplication

multiplication:
        ;; eax already contain the previous result that has to be
        ;; multiplied by ecx (result of factor())
        imul    ecx
        jmp     next_iteration
division:
        xor     edx, edx
        cdq
        idiv    ecx
        jmp     next_iteration


next_iteration:
        jmp     while_div_or_mul

term_out:
        leave
        ret

; `expression(char *p, int *i)`
;       Evaluates "term" + "term" or "term" - "term" expressions 
; @params:
;	p -> the string to be parsed
;	i -> current position in the string
; @returns:
;	the result of the parsed expression
expression:
        push    ebp
        mov     ebp, esp

        ; Get the first term of the big sum
        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    term
        add     esp, 8

        mov     ebx, dword[ebp + 8]     ; the beginning of the array
        mov     edx, dword[ebp + 12]
        ; add     ebx, dword[edx]

        mov     ecx, dword[edx]         ; counter for the loop
        xor     edx, edx                ; edx will be used as a score for paranthesis
                                        ; opening a paranthesis will increase the score by 1,
                                        ; and closing one will decrement the score
                                        

through_string:
        ; pusha
        ; push ecx
        ; push formatIndex
        ; call printf
        ; add esp, 8
        ; popa

        test    edx, edx
        cmp     edx, 0
        jne     check_par               ; this cannot be a term of the big sum,
                                        ; because parantheses score is different than 0
        cmp     byte[ebx + ecx], '+'
        je      found_next_term
        cmp     byte[ebx + ecx], '-'
        je      found_next_term

    check_par:
        cmp     byte[ebx + ecx], '('
        je      opened_par
        cmp     byte[ebx + ecx], ')'
        je      closed_par

    goto_next_term:
        inc     ecx
        cmp     byte[ebx + ecx], 0  ; if the '\0' character was encountered, stop the loop
        jne     through_string
        jmp     expression_out

found_next_term:
        push    edx
        mov     edx, dword[ebp + 12]        ; the pointer
        mov     dword[edx], ecx
        inc     dword[edx]                  ; get rid of the sign
        pop     edx


        push    edx
        push    eax                         ; push eax to use its value as
                                            ; dword[esp + 4] after function call
        push    ebx                         ; save the values of ebx,m ecx and edx
        push    ecx

        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    term
        add     esp, 8

        pop     ecx
        pop     ebx
        cmp     byte[ecx + ebx], '+'
        je      addition

        sub     dword[esp], eax         ; from the old eax subtract the new eax
        jmp     gather_eax

    addition:
        add     dword[esp], eax
        jmp     gather_eax

    gather_eax:
        pop     eax                         ; and get the updated eax
        pop     edx

        jmp     check_par


opened_par:
        inc     edx
        jmp     goto_next_term

closed_par:
        test    edx, edx
        jz      kick_out_par
        dec     edx
        ; cmp     edx, 0
        ; jl      kick_out_par                     ; the expression currently evaluated ended
        jmp     goto_next_term

kick_out_par:
        push    eax
        mov     eax, dword[ebp + 12]            ; i
        inc     dword[eax]                      ; get past the closing brace that ended the current expression
        pop     eax
        jmp     expression_out

expression_out:
        leave
        ret
