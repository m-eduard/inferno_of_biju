section .text

global expression
global term
global factor


; `factor(char *p, int *i)`
;       Evaluates "(expression)" or "number" expressions 
; @params:
;	p -> the string to be parsed
;	i -> current position in the string
; @returns:
;	the result of the parsed expression
factor:
        push    ebp
        mov     ebp, esp
        push    ebx                     ; comply to cdecl convention, saving ebx

        mov     ebx, dword[ebp + 8]     ; the beginning of the string
        mov     edx, dword[ebp + 12]    ; pointer to the current index

        add     ebx, dword[edx]         ; the address of the current inspected
                                        ; character in the string
        cmp     byte[ebx], '('
        je      eval_expression

;; If the first character is not a paranthesis,
;; then it means that it's a number and has to be
;; calculated
        xor     eax, eax                ; store the number in eax

number_loop:
        ;; The character should have a value between
        ;; '0' and '9' to be part of a number
        cmp     byte[ebx], '0'
        jl      factor_out
        cmp     byte[ebx], '9'
        jg      factor_out

        lea     eax, [eax * 5]          ; multiply the old eax by 10 (5 * 2)
        lea     eax, [eax * 2]          ; (because: lea eax, [eax * 10] is
                                        ;  not valid)

        ;; Add the new digit to the number
        xor     ecx, ecx                ; store the current digit in ecx
        mov     cl, byte[ebx]
        add     eax, ecx
        sub     eax, '0'                ; eax becomes (10 * eax)
                                        ;   + (char_digit - '0')

        inc     dword[edx]              ; increment the *i
        inc     ebx
        jmp     number_loop

eval_expression:
        inc     dword[edx]              ; get rid of the first paranthesis: '('

        ;; Since after this call, the registers will no longer be used
        ;; in this function, if they are modified in expression() it doesn't
        ;; matter => no need to push the values of the registers to the stack
        push    dword[ebp + 12]         ; calculate the expression
        push    dword[ebp + 8]          ; until the closing brace is reached
        call    expression
        add     esp, 8

        ;; Here, eax contains the result returned by the expression() call,
        ;; so nothing more has to be done
factor_out:
        pop     ebx
        leave
        ret


; `term(char *p, int *i)`
;       Evaluates "factor" * "factor" or "factor" / "factor" expressions 
; @params:
;	p -> the string to be parsed
;	i -> current position in the string
; @returns:
;	the result of the parsed expression
term:
        push    ebp
        mov     ebp, esp
        push    ebx                     ; comply to cdecl convention, saving ebx

        ;; Evaluation of the first factor inside the term
        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    factor
        add     esp, 8
        ;; eax has now the result generated by the first evaluation
        ;; and will be used to find the total result

        mov     ebx, dword[ebp + 8]     ; the beginning of the string
        mov     edx, dword[ebp + 12]    ; pointer to the current index


;; Formal initial ebx push (because in every for iteration
;; ebx have to get its original value, after being modified
;; into ebx + *i in a previous iteration)
        push    ebx

;; *i is updated in every factor() call, and the loop goes until the character
;;  pointed by (p + *i) is different than '/' or '*'
while_div_or_mul:
        pop     ebx                     ; every iteration modifies ebx into ebx + *i
        push    ebx
        add     ebx, dword[edx]         ; the address of the sign (p + *i)

        cmp     byte[ebx], '/'          ; the current sign should be either '/', either '*'
        je      eval_next_factor
        cmp     byte[ebx], '*'
        je      eval_next_factor
        jmp     term_out

eval_next_factor:
        inc     dword[edx]              ; go past the sign

        push    eax                     ; save the used registers on the stack
        push    edx                     ; (ebx is callee saved)

;; Calculate the value of the current factor
        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    factor
        add     esp, 8
        mov     ecx, eax                ; store the result of factor() in ecx

        pop     edx                     ; restore the registers from stack
        pop     eax

;; Decide what operation should be made between eax and ecx
        cmp     byte[ebx], '/'          ; the sign is either '*' or '/'
        je      division
        jmp     multiplication

multiplication:
;; eax already contain the previous result that has to be
;; multiplied by ecx (result of last factor() call)
        push    edx                     ; edx will be modified after mul
        imul    ecx
        pop     edx
        jmp     next_iteration
division:
;; eax already contain the first factor (the numerator)
        push    edx
        xor     edx, edx
        cdq
        idiv    ecx
        pop     edx
        jmp     next_iteration

next_iteration:
        jmp     while_div_or_mul

term_out:
        pop     ebx
        leave
        ret


; `expression(char *p, int *i)`
;       Evaluates "term" + "term" or "term" - "term" expressions 
; @params:
;	p -> the string to be parsed
;	i -> current position in the string
; @returns:
;	the result of the parsed expression
expression:
        push    ebp
        mov     ebp, esp

        ; Get the first term of the big sum
        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    term
        add     esp, 8

        mov     ebx, dword[ebp + 8]     ; the beginning of the array
        mov     edx, dword[ebp + 12]    ; pointer to the current position index

        mov     ecx, dword[edx]         ; counter for the loop
        xor     edx, edx                ; edx will be used as a score for
                                        ; parantheses (opening a paranthesis
                                        ; will increase the score by 1, and
                                        ; closing one will decrement the score)

through_string:
        test    edx, edx
        jne     check_par               ; this cannot be the beginning of a
                                        ; term for the big sum, because paran-
                                        ; theses score is different than 0
        cmp     byte[ebx + ecx], '+'
        je      found_next_term
        cmp     byte[ebx + ecx], '-'
        je      found_next_term

    check_par:
        cmp     byte[ebx + ecx], '('
        je      opened_par
        cmp     byte[ebx + ecx], ')'
        je      closed_par

    goto_next_term:
        inc     ecx
        cmp     byte[ebx + ecx], 0      ; if the '\0' character was
                                        ; encountered, stop the loop
        jne     through_string
        jmp     expression_out

found_next_term:
        push    edx
        mov     edx, dword[ebp + 12]    ; - pointer to the position index
        mov     dword[edx], ecx         ; - set the current position
        inc     dword[edx]              ; - get rid of the sign, going over it
        pop     edx


        push    edx
        push    eax                     ; push eax to use its value as
                                        ; dword[esp] after function call
                                        ; (because function will return its
                                        ;  its result in eax, the old eax
                                        ;  will be overridden)
        push    ecx

;; Evaluate the current term (ebx is callee saved)
        push    dword[ebp + 12]
        push    dword[ebp + 8]
        call    term
        add     esp, 8

        pop     ecx
        cmp     byte[ecx + ebx], '+'    ; check the sign placed before the
                                        ; evaluated expression
        je      addition

        sub     dword[esp], eax         ; from the old eax subtract the new eax
        jmp     gather_eax

    addition:
        add     dword[esp], eax         ; to the old eax, stored on the stack,
                                        ; add the result of term() call, stored
                                        ; in eax
        jmp     gather_eax

    gather_eax:
        pop     eax                     ; get the updated eax
        pop     edx

        jmp     check_par

;; Increment the parantheses score, if a '(' is encountered
opened_par:
        inc     edx
        jmp     goto_next_term

;; Decrement the parantheses score, if a ')' was encountered
closed_par:
        dec     edx
        cmp     edx, 0
        jl      kick_out_par            ; the expression currently evaluated]
                                        ; ended (the score has to be negative,
                                        ; because the first paranthesis was
                                        ; removed from the expression in the
                                        ; factor() call, therefore we know that
                                        ; the evaluation of the expression is
                                        ; finished when the final paranthesis,
                                        ; correspoding to the removed one,
                                        ; was reached)
        jmp     goto_next_term

kick_out_par:
        push    eax
        mov     eax, dword[ebp + 12]    ; pointer i
        inc     dword[eax]              ; go past the closing brace that ended
                                        ; the current expression
        pop     eax
        jmp     expression_out

expression_out:
        leave
        ret
